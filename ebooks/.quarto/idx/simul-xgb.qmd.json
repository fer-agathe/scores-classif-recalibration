{"title":"Extreme Gradient Boosting","markdown":{"headingText":"Extreme Gradient Boosting","headingAttr":{"id":"sec-simul-xgb","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n\n:::{.callout-note}\n\nThis chapter investigates how the distribution of estimated scores by an extreme gradient boosting model evolves with the number of boosting iterations. In the models, we vary the maximum depth of trees and consider boosting iterations up to 400. For each configuration, we compute the predicted scores from iteration 1 to 400; for each boosting iteration, we use the predicted scores (on train, calibration and test sets) to compute various metrics (performance, calibration, divergence between the distribution of scores and that of true underlying probabilities) on both the initial and recalibrated scores.\n\n:::\n\n```{r load-libraries}\nlibrary(tidyverse)\nlibrary(ggh4x)\nlibrary(ggrepel)\nlibrary(rpart)\nlibrary(locfit)\nlibrary(philentropy)\n\n# Colours for train/validation/test\ncolour_samples <- c(\n  \"Train\" = \"#0072B2\",\n  \"Validation\" = \"#009E73\",\n  \"Calibration\" = \"#CC79A7\",\n  \"Test\" = \"#D55E00\"\n)\n\ncolour_recalib <- c(\n  \"None\" = \"#88CCEE\",\n  \"Platt\" = \"#44AA99\",\n  \"Isotonic\" = \"#882255\"\n)\n```\n\n\n\n```{r define-theme_paper}\n#| code-fold: true\n#| code-summary: definition of the `theme_paper()` function (for ggplot2 graphs)\n#' Theme for ggplot2\n#'\n#' @param ... arguments passed to the theme function\n#' @export\n#' @importFrom ggplot2 element_rect element_text element_blank element_line unit\n#'   rel\ntheme_paper <- function (...) {\n  ggthemes::theme_base() +\n    theme(\n      plot.background = element_blank(),\n      legend.background = element_rect(\n        fill = \"transparent\", linetype=\"solid\", colour =\"black\"),\n      legend.position = \"bottom\",\n      legend.direction = \"horizontal\",\n      legend.box = \"horizontal\",\n      legend.key = element_blank()\n    )\n}\n```\n\n## Data\n\n\nWe generate data using the first 12 scenarios from @Ojeda_2023 and an additional set of 4 scenarios in which the true probability does not depend on the predictors in a linear way (see [Chapter -@sec-simul-data]).\n\n```{r source-data-ojeda}\nsource(\"../scripts/functions/simul-data.R\")\nlibrary(ks)\nsource(\"../scripts/functions/subsample_target_distribution.R\")\n```\n\nWhen we simulate a dataset, we draw the following number of observations:\n```{r define-nb_obs}\nnb_obs <- 10000\n```\n\n\n```{r}\n#| code-fold: true\n#| code-summary: Definition of the 16 scenarios\n# Coefficients beta\ncoefficients <- list(\n  # First category (baseline, 2 covariates)\n  c(0.5, 1),  # scenario 1, 0 noise variable\n  c(0.5, 1),  # scenario 2, 10 noise variables\n  c(0.5, 1),  # scenario 3, 50 noise variables\n  c(0.5, 1),  # scenario 4, 100 noise variables\n  # Second category (same as baseline, with lower number of 1s)\n  c(0.5, 1),  # scenario 5, 0 noise variable\n  c(0.5, 1),  # scenario 6, 10 noise variables\n  c(0.5, 1),  # scenario 7, 50 noise variables\n  c(0.5, 1),  # scenario 8, 100 noise variables\n  # Third category (same as baseline but with 5 num. and 5 categ. covariates)\n  c(0.1, 0.2, 0.3, 0.4, 0.5, 0.01, 0.02, 0.03, 0.04, 0.05),\n  c(0.1, 0.2, 0.3, 0.4, 0.5, 0.01, 0.02, 0.03, 0.04, 0.05),\n  c(0.1, 0.2, 0.3, 0.4, 0.5, 0.01, 0.02, 0.03, 0.04, 0.05),\n  c(0.1, 0.2, 0.3, 0.4, 0.5, 0.01, 0.02, 0.03, 0.04, 0.05),\n  # Fourth category (nonlinear predictor, 3 covariates)\n  c(0.5, 1, .3),  # scenario 5, 0 noise variable\n  c(0.5, 1, .3),  # scenario 6, 10 noise variables\n  c(0.5, 1, .3),  # scenario 7, 50 noise variables\n  c(0.5, 1, .3)  # scenario 8, 100 noise variables\n)\n\n# Mean parameter for the normal distribution to draw from to draw num covariates\nmean_num <- list(\n  # First category (baseline, 2 covariates)\n  rep(0, 2),  # scenario 1, 0 noise variable\n  rep(0, 2),  # scenario 2, 10 noise variables\n  rep(0, 2),  # scenario 3, 50 noise variables\n  rep(0, 2),  # scenario 4, 100 noise variables\n  # Second category (same as baseline, with lower number of 1s)\n  rep(0, 2),  # scenario 5, 0 noise variable\n  rep(0, 2),  # scenario 6, 10 noise variables\n  rep(0, 2),  # scenario 7, 50 noise variables\n  rep(0, 2),  # scenario 8, 100 noise variables\n  # Third category (same as baseline but with 5 num. and 5 categ. covariates)\n  rep(0, 5),\n  rep(0, 5),\n  rep(0, 5),\n  rep(0, 5),\n  # Fourth category (nonlinear predictor, 3 covariates)\n  rep(0, 3),\n  rep(0, 3),\n  rep(0, 3),\n  rep(0, 3)\n)\n# Sd parameter for the normal distribution to draw from to draw num covariates\nsd_num <- list(\n  # First category (baseline, 2 covariates)\n  rep(1, 2),  # scenario 1, 0 noise variable\n  rep(1, 2),  # scenario 2, 10 noise variables\n  rep(1, 2),  # scenario 3, 50 noise variables\n  rep(1, 2),  # scenario 4, 100 noise variables\n  # Second category (same as baseline, with lower number of 1s)\n  rep(1, 2),  # scenario 5, 0 noise variable\n  rep(1, 2),  # scenario 6, 10 noise variables\n  rep(1, 2),  # scenario 7, 50 noise variables\n  rep(1, 2),  # scenario 8, 100 noise variables\n  # Third category (same as baseline but with 5 num. and 5 categ. covariates)\n  rep(1, 5),\n  rep(1, 5),\n  rep(1, 5),\n  rep(1, 5),\n  # Fourth category (nonlinear predictor, 3 covariates)\n  rep(1, 3),\n  rep(1, 3),\n  rep(1, 3),\n  rep(1, 3)\n)\n\nparams_df <- tibble(\n  scenario = 1:16,\n  coefficients = coefficients,\n  n_num = c(rep(2, 8), rep(5, 4), rep(3, 4)),\n  add_categ = c(rep(FALSE, 8), rep(TRUE, 4), rep(FALSE, 4)),\n  n_noise = rep(c(0, 10, 50, 100), 4),\n  mean_num = mean_num,\n  sd_num = sd_num,\n  size_train = rep(nb_obs, 16),\n  size_valid = rep(nb_obs, 16),\n  size_calib = rep(nb_obs, 16),\n  size_test = rep(nb_obs, 16),\n  transform_probs = c(rep(FALSE, 4), rep(TRUE, 4), rep(FALSE, 4), rep(FALSE, 4)),\n  linear_predictor = c(rep(TRUE, 12), rep(FALSE, 4)),\n  seed = 202105\n)\nrm(coefficients, mean_num, sd_num)\n```\n\n## Metrics\n\nWe load the functions from [Chapter -@sec-metrics] to compute performance, calibration and divergence metrics.\n\n```{r source-metrics}\nsource(\"../scripts/functions/metrics.R\")\n```\n\n## Simulations Setup\n\n\nTo train the models, we rely on the {xgboost} R package.\n```{r load-xgboost}\nlibrary(xgboost)\n```\n\nHere, we define a function to recalibrate predicted scores using either Platt scaling or isotonic regression. The recalibration algorithm is first trained on the calibration set and then applied to both the calibration and test sets.\n\n```{r define-recalibrate}\n#' Recalibrates scores using a calibration\n#' \n#' @param obs_calib vector of observed events in the calibration set\n#' @param scores_calib vector of predicted probabilities in the calibration set\n#' @param obs_test vector of observed events in the test set\n#' @param scores_test vector of predicted probabilities in the test set\n#' @param method recalibration method (`\"platt\"` for Platt scaling, \n#'   `\"isotonic\"` for isotonic regression)\n#' @returns list of two elements: recalibrated scores on the calibration set,\n#'   recalibrated scores on the test set\nrecalibrate <- function(obs_calib,\n                        obs_test,\n                        pred_calib,\n                        pred_test,\n                        method = c(\"platt\", \"isotonic\")) {\n  data_calib <- tibble(d = obs_calib, scores = pred_calib)\n  data_test <- tibble(d = obs_test, scores = pred_test)\n  \n  if (method == \"platt\") {\n    lr <- glm(d ~ scores, family = binomial(link = 'logit'), data = data_calib)\n    score_c_calib <- predict(lr, newdata = data_calib, type = \"response\")\n    score_c_test <- predict(lr, newdata = data_test, type = \"response\")\n  } else if (method == \"isotonic\") {\n    iso <- isoreg(x = data_calib$scores, y = data_calib$d)\n    fit_iso <- as.stepfun(iso)\n    score_c_calib <- fit_iso(data_calib$scores)\n    score_c_test <- fit_iso(data_test$scores)\n    \n  } else {\n    stop(\"Unrecognized method: platt or isotonic only\")\n  }\n  # Format results in tibbles:\n  # For calibration set\n  tb_score_c_calib <- tibble(\n    d = obs_calib,\n    p_u = pred_calib,\n    p_c = score_c_calib\n  )\n  # For test set\n  tb_score_c_test <- tibble(\n    d = obs_test,\n    p_u = pred_test,\n    p_c = score_c_test\n  )\n  \n  list(\n    tb_score_c_calib = tb_score_c_calib,\n    tb_score_c_test = tb_score_c_test\n  )\n  \n}\n```\n\n\nAs explained in the foreword of this page, we compute metrics based on scores obtained at various boosting iterations. To do so, we define a function, `get_metrics_nb_iter()`{.R}, that will be applied to a fitted model. This function will be called for all the boosting iterations (controlled by the `nb_iter` argument). The function returns a list with the following elements:\n\n- `scenario`: the ID of the scenario\n- `ind`: the index of the grid search (so that we can join with the hyperparameters values, if needed)\n- `repn`: the ID of the replication\n- `nb_iter`: the boosting iteration at which the metrics are computed\n- `tb_metrics`: the tibble with the performance, calibration, and divergence metrics (one row for the train sample, one row for the calibration sample, one row for the validation sample, and one row for the test sample)\n- `tb_prop_scores`: additional metrics ($\\mathbb{P}(q_1 < \\hat{s}(\\mathbf{x}) < q_2)$ for multiple values for $q_1$ and $q_2 = 1-q_1$)\n- `scores_hist`: elements to be able to plot an histogram of the scores on both the train set and the test set (using 20 equally-sized bins over $[0,1]$).\n\n\n```{r define-get_metrics_nb_iter}\n#| code-fold: true\n#| code-summary: Function `get_metrics_nb_iter()`{.R}\n#' Computes the performance and calibration metrics for an xgb model,\n#' depending on the number of iterations kept.\n#'\n#' @param nb_iter number of boosting iterations to keep\n#' @param params hyperparameters of the current model\n#' @param fitted_xgb xgb estimated model\n#' @param tb_train_xgb train data (in xgb.DMatrix format)\n#' @param tb_valid_xgb validation data (in xgb.DMatrix format)\n#' @param tb_calib_xgb calibration data (in xgb.DMatrix format)\n#' @param tb_test_xgb test data (in xgb.DMatrix format)\n#' @param simu_data simulated dataset\n#' @param true_prob list with true probabilities on train, calibration,\n#'  validation and test sets\nget_metrics_nb_iter <- function(nb_iter,\n                                params,\n                                fitted_xgb,\n                                tb_train_xgb,\n                                tb_valid_xgb,\n                                tb_calib_xgb,\n                                tb_test_xgb,\n                                simu_data,\n                                true_prob) {\n\n  ind <- params$ind\n  max_depth <- params$max_depth\n  tb_train <- simu_data$data$train |> rename(d = y)\n  tb_valid <- simu_data$data$valid |> rename(d = y)\n  tb_calib <- simu_data$data$calib |> rename(d = y)\n  tb_test <- simu_data$data$test |> rename(d = y)\n\n  # Predicted scores\n  scores_train <- predict(fitted_xgb, tb_train_xgb, iterationrange = c(1, nb_iter))\n  scores_valid <- predict(fitted_xgb, tb_valid_xgb, iterationrange = c(1, nb_iter))\n  scores_calib <- predict(fitted_xgb, tb_calib_xgb, iterationrange = c(1, nb_iter))\n  scores_test <- predict(fitted_xgb, tb_test_xgb, iterationrange = c(1, nb_iter))\n  \n  # Recalibration\n  # Platt scaling\n  res_recalibration_platt <- recalibrate(\n    obs_calib = tb_calib$d, \n    obs_test = tb_test$d, \n    pred_calib = scores_calib, \n    pred_test = scores_test, \n    method = \"platt\"\n  )\n  scores_c_platt_calib <- res_recalibration_platt$tb_score_c_calib$p_c\n  scores_c_platt_test <- res_recalibration_platt$tb_score_c_test$p_c\n  \n  # Isotonic regression\n  res_recalibration_iso <- recalibrate(\n    obs_calib = tb_calib$d, \n    obs_test = tb_test$d, \n    pred_calib = scores_calib, \n    pred_test = scores_test, \n    method = \"isotonic\"\n  )\n  scores_c_iso_calib <- res_recalibration_iso$tb_score_c_calib$p_c\n  scores_c_iso_test <- res_recalibration_iso$tb_score_c_test$p_c\n\n  ## Histogram of scores----\n  breaks <- seq(0, 1, by = .05)\n  scores_train_hist <- hist(scores_train, breaks = breaks, plot = FALSE)\n  scores_calib_hist <- hist(scores_calib, breaks = breaks, plot = FALSE)\n  scores_valid_hist <- hist(scores_valid, breaks = breaks, plot = FALSE)\n  scores_test_hist <- hist(scores_test, breaks = breaks, plot = FALSE)\n  scores_c_platt_calib_hist <- hist(scores_c_platt_calib, breaks = breaks, plot = FALSE)\n  scores_c_platt_test_hist <- hist(scores_c_platt_test, breaks = breaks, plot = FALSE)\n  scores_c_iso_calib_hist <- hist(scores_c_iso_calib, breaks = breaks, plot = FALSE)\n  scores_c_iso_test_hist <- hist(scores_c_iso_test, breaks = breaks, plot = FALSE)\n  \n  scores_hist <- list(\n    train = scores_train_hist,\n    valid = scores_valid_hist,\n    calib = scores_calib_hist,\n    test = scores_test_hist,\n    calib_c_platt = scores_c_platt_calib_hist,\n    test_c_platt = scores_c_platt_test_hist,\n    calib_c_iso = scores_c_iso_calib_hist,\n    test_c_iso = scores_c_iso_test_hist,\n    scenario = simu_data$scenario,\n    ind = ind,\n    repn = simu_data$repn,\n    max_depth = params$max_depth,\n    nb_iter = nb_iter\n  )\n\n  ## Estimation of P(q1 < score < q2)----\n  prop_btw_q_h <- function(s, sample_name, recalib_name) {\n    map(\n      c(.1, .2, .3, .4),\n      ~prop_btw_quantiles(s = s, q1 = .x)\n    ) |>\n      list_rbind() |>\n      mutate(sample = sample_name, recalib = recalib_name)\n  }\n  \n  proq_scores_train <- prop_btw_q_h(\n    scores_train, sample_name = \"train\", recalib_name = \"none\"\n  )\n  proq_scores_valid <- prop_btw_q_h(\n    scores_valid, sample_name = \"valid\", recalib_name = \"none\"\n  )\n  proq_scores_calib <- prop_btw_q_h(\n    scores_calib, sample_name = \"calib\", recalib_name = \"none\"\n  )\n  proq_scores_test <- prop_btw_q_h(\n    scores_test, sample_name = \"test\", recalib_name = \"none\"\n  )\n  proq_scores_c_platt_calib <- prop_btw_q_h(\n    scores_c_platt_calib, sample_name = \"calib\", recalib_name = \"platt\"\n  )\n  proq_scores_c_platt_test <- prop_btw_q_h(\n    scores_c_platt_test, sample_name = \"test\", recalib_name = \"platt\"\n  )\n  proq_scores_c_iso_calib <- prop_btw_q_h(\n    scores_c_iso_calib, sample_name = \"calib\", recalib_name = \"isotonic\"\n  )\n  proq_scores_c_iso_test <- prop_btw_q_h(\n    scores_c_iso_test, sample_name = \"test\", recalib_name = \"isotonic\"\n  )\n  \n\n  ## Dispersion Metrics----\n  disp_train <- dispersion_metrics(\n    true_probas = true_prob$train, scores = scores_train\n  ) |> \n    mutate(sample = \"train\", recalib = \"none\")\n  disp_valid <- dispersion_metrics(\n    true_probas = true_prob$valid, scores = scores_valid\n  ) |>\n    mutate(sample = \"valid\", recalib = \"none\")\n  \n  disp_calib <- dispersion_metrics(\n    true_probas = true_prob$calib, scores = scores_calib\n  ) |>\n    mutate(sample = \"calib\", recalib = \"none\")\n  \n  disp_test <- dispersion_metrics(\n    true_probas = true_prob$test, scores = scores_test\n  ) |> \n    mutate(sample = \"test\", recalib = \"none\")\n  \n  \n  disp_c_platt_calib <- dispersion_metrics(\n    true_probas = true_prob$calib, scores = scores_c_platt_calib\n  ) |>\n    mutate(sample = \"calib\", recalib = \"platt\")\n  \n  disp_c_platt_test <- dispersion_metrics(\n    true_probas = true_prob$test, scores = scores_c_platt_test\n  ) |> \n    mutate(sample = \"test\", recalib = \"platt\")\n  \n  disp_c_iso_calib <- dispersion_metrics(\n    true_probas = true_prob$calib, scores = scores_c_iso_calib\n  ) |>\n    mutate(sample = \"calib\", recalib = \"isotonic\")\n  \n  disp_c_iso_test <- dispersion_metrics(\n    true_probas = true_prob$test, scores = scores_c_iso_test\n  ) |> \n    mutate(sample = \"test\", recalib = \"isotonic\")\n  \n  # Performance and Calibration Metrics\n  # We add very small noise to predicted scores\n  # otherwise the local regression may crash\n  scores_train_noise <- scores_train +\n    runif(n = length(scores_train), min = 0, max = 0.01)\n  scores_train_noise[scores_train_noise > 1] <- 1\n  metrics_train <- compute_metrics(\n    obs = tb_train$d, scores = scores_train_noise, true_probas = true_prob$train\n  ) |> mutate(sample = \"train\", recalib = \"none\")\n  \n  scores_valid_noise <- scores_valid +\n    runif(n = length(scores_valid), min = 0, max = 0.01)\n  scores_valid_noise[scores_valid_noise > 1] <- 1\n  metrics_valid <- compute_metrics(\n    obs = tb_valid$d, scores = scores_valid_noise, true_probas = true_prob$valid\n  ) |> mutate(sample = \"valid\", recalib = \"none\")\n  \n  scores_calib_noise <- scores_calib +\n    runif(n = length(scores_calib), min = 0, max = 0.01)\n  scores_calib_noise[scores_calib_noise > 1] <- 1\n  metrics_calib <- compute_metrics(\n    obs = tb_calib$d, scores = scores_calib_noise, true_probas = true_prob$calib\n  ) |> mutate(sample = \"calib\", recalib = \"none\")\n  \n  scores_test_noise <- scores_test +\n    runif(n = length(scores_test), min = 0, max = 0.01)\n  scores_test_noise[scores_test_noise > 1] <- 1\n  metrics_test <- compute_metrics(\n    obs = tb_test$d, scores = scores_test_noise, true_probas = true_prob$test\n  ) |> mutate(sample = \"test\", recalib = \"none\")\n  \n  # With recalibrated scores (platt)\n  scores_c_platt_calib_noise <- scores_c_platt_calib +\n    runif(n = length(scores_c_platt_calib), min = 0, max = 0.01)\n  scores_c_platt_calib_noise[scores_c_platt_calib_noise > 1] <- 1\n  metrics_c_platt_calib <- compute_metrics(\n    obs = tb_calib$d, scores = scores_c_platt_calib_noise, \n    true_probas = true_prob$calib\n  ) |> mutate(sample = \"calib\", recalib = \"platt\")\n  \n  scores_c_platt_test_noise <- scores_c_platt_test +\n    runif(n = length(scores_c_platt_test), min = 0, max = 0.01)\n  scores_c_platt_test_noise[scores_c_platt_test_noise > 1] <- 1\n  metrics_c_platt_test <- compute_metrics(\n    obs = tb_test$d, scores = scores_c_platt_test_noise, \n    true_probas = true_prob$test\n  ) |> mutate(sample = \"test\", recalib = \"platt\")\n  \n  # With recalibrated scores (isotonic)\n  scores_c_iso_calib_noise <- scores_c_iso_calib +\n    runif(n = length(scores_c_iso_calib), min = 0, max = 0.01)\n  scores_c_iso_calib_noise[scores_c_iso_calib_noise > 1] <- 1\n  metrics_c_iso_calib <- compute_metrics(\n    obs = tb_calib$d, scores = scores_c_iso_calib_noise, \n    true_probas = true_prob$calib\n  ) |> mutate(sample = \"calib\", recalib = \"isotonic\")\n  \n  scores_c_iso_test_noise <- scores_c_iso_test +\n    runif(n = length(scores_c_iso_test), min = 0, max = 0.01)\n  scores_c_iso_test_noise[scores_c_iso_test_noise > 1] <- 1\n  metrics_c_iso_test <- compute_metrics(\n    obs = tb_test$d, scores = scores_c_iso_test_noise, \n    true_probas = true_prob$test\n  ) |> mutate(sample = \"test\", recalib = \"isotonic\")\n  \n  tb_metrics <- metrics_train |>\n    bind_rows(metrics_valid) |>\n    bind_rows(metrics_calib) |>\n    bind_rows(metrics_test) |>\n    bind_rows(metrics_c_platt_calib) |>\n    bind_rows(metrics_c_platt_test) |>\n    bind_rows(metrics_c_iso_calib) |>\n    bind_rows(metrics_c_iso_test) |>\n    left_join(\n      disp_train |>\n        bind_rows(disp_valid) |> \n        bind_rows(disp_calib) |> \n        bind_rows(disp_test) |> \n        bind_rows(disp_c_platt_calib) |> \n        bind_rows(disp_c_platt_test) |> \n        bind_rows(disp_c_iso_calib) |> \n        bind_rows(disp_c_iso_test),\n      by = c(\"sample\", \"recalib\")\n    ) |>\n    mutate(\n      scenario = simu_data$scenario,\n      ind = ind,\n      repn = simu_data$repn,\n      max_depth = params$max_depth,\n      nb_iter = nb_iter\n    )\n  \n  tb_prop_scores <- proq_scores_train |>\n    bind_rows(proq_scores_valid) |>\n    bind_rows(proq_scores_calib) |>\n    bind_rows(proq_scores_test) |>\n    bind_rows(proq_scores_c_platt_calib) |>\n    bind_rows(proq_scores_c_platt_test) |>\n    bind_rows(proq_scores_c_iso_calib) |>\n    bind_rows(proq_scores_c_iso_test) |>\n    mutate(\n      scenario = simu_data$scenario,\n      ind = ind,\n      repn = simu_data$repn,\n      max_depth = params$max_depth,\n      nb_iter = nb_iter\n    )\n\n  list(\n    scenario = simu_data$scenario,     # data scenario\n    ind = ind,                         # index for grid\n    repn = simu_data$repn,             # data replication ID\n    nb_iter = nb_iter,                 # number of boosting iterations\n    tb_metrics = tb_metrics,           # table with performance/calib/divergence\n                                       #  metrics\n    tb_prop_scores = tb_prop_scores,   # table with P(q1 < score < q2)\n    scores_hist = scores_hist          # histogram of scores\n  )\n}\n```\n\n\n\nWe define another function, `simul_xgb()`{.R} which trains an extreme gradient boosting model for a single replication. It calls the `get_metrics_nb_iter()`{.R} on each of the boosting iterations of the model from the second to the last (400th), and returns a list of length 400-1 where each element is a list returned by the `get_metrics_nb_iter()`{.R}.\n\n```{r define-simul_xgb}\n#| code-fold: true\n#| code-summary: Function `simul_xgb()`{.R}\n#' Train an xgboost model and compute performance, calibration, and dispersion\n#' metrics\n#'\n#' @param params tibble with hyperparameters for the simulation\n#' @param ind index of the grid (numerical ID)\n#' @param simu_data simulated data obtained with `simulate_data_wrapper()`\nsimul_xgb <- function(params,\n                      ind,\n                      simu_data) {\n  tb_train <- simu_data$data$train |> rename(d = y)\n  tb_valid <- simu_data$data$valid |> rename(d = y)\n  tb_calib <- simu_data$data$calib |> rename(d = y)\n  tb_test <- simu_data$data$test |> rename(d = y)\n  true_prob <-\n    list(\n      train = simu_data$data$probs_train,\n      valid = simu_data$data$probs_valid,\n      calib = simu_data$data$probs_calib,\n      test = simu_data$data$probs_test\n    )\n\n  ## Format data for xgboost----\n  tb_train_xgb <- xgb.DMatrix(\n    data = model.matrix(d ~ -1 + ., tb_train), label = tb_train$d\n  )\n  tb_valid_xgb <- xgb.DMatrix(\n    data = model.matrix(d ~ -1 + ., tb_valid), label = tb_valid$d\n  )\n  tb_calib_xgb <- xgb.DMatrix(\n    data = model.matrix(d ~ -1 + ., tb_calib), label = tb_calib$d\n  )\n  tb_test_xgb <- xgb.DMatrix(\n    data = model.matrix(d ~ -1 + ., tb_test), label = tb_test$d\n  )\n  # Parameters for the algorithm\n  param <- list(\n    max_depth = params$max_depth, #Note: root node is indexed 0\n    eta = params$eta,\n    nthread = 1,\n    objective = \"binary:logistic\",\n    eval_metric = \"auc\"\n  )\n  watchlist <- list(train = tb_train_xgb, eval = tb_valid_xgb)\n\n  ## Estimation----\n  xgb_fit <- xgb.train(\n    param, tb_train_xgb,\n    nrounds = params$nb_iter_total,\n    watchlist,\n    verbose = 0\n  )\n\n  # Then, for each boosting iteration number up to params$nb_iter_total\n  # compute the predicted scores and evaluate the metrics\n  resul <- map(\n    seq(2, params$nb_iter_total),\n    ~get_metrics_nb_iter(\n      nb_iter = .x,\n      params = params,\n      fitted_xgb = xgb_fit,\n      tb_train_xgb = tb_train_xgb,\n      tb_valid_xgb = tb_valid_xgb,\n      tb_calib_xgb = tb_calib_xgb,\n      tb_test_xgb = tb_test_xgb,\n      simu_data = simu_data,\n      true_prob = true_prob\n    ),\n  )\n  resul\n}\n\nsimulate_xgb_scenario <- function(scenario, params_df, repn) {\n  # Generate Data\n  simu_data <- simulate_data_wrapper(\n    scenario = scenario,\n    params_df = params_df,\n    repn = repn\n  )\n\n  # Looping over the grid hyperparameters for the scenario\n  res_simul <- vector(mode = \"list\", length = nrow(grid))\n  cli::cli_progress_bar(\"Iteration grid\", total = nrow(grid), type = \"tasks\")\n  for (j in 1:nrow(grid)) {\n    curent_params <- grid |> dplyr::slice(!!j)\n    res_simul[[j]] <- simul_xgb(\n      params = curent_params,\n      ind = curent_params$ind,\n      simu_data = simu_data\n    )\n    cli::cli_progress_update()\n  }\n\n\n  # The metrics computed for all set of hyperparameters (identified with `ind`)\n  # and for each number of boosting iterations (`nb_iter`), for the current\n  # scenario (`scenario`) and current replication number (`repn`)\n  metrics_simul <- map(\n    res_simul,\n    function(simul_grid_j) map(simul_grid_j, \"tb_metrics\") |> list_rbind()\n  ) |>\n    list_rbind()\n\n  # P(q_1<s(x)<q_2)\n  prop_scores_simul <- map(\n    res_simul,\n    function(simul_grid_j) map(simul_grid_j, \"tb_prop_scores\") |> list_rbind()\n  ) |>\n    list_rbind()\n\n  # Histogram of estimated scores\n  scores_hist <- map(\n    res_simul,\n    function(simul_grid_j) map(simul_grid_j, \"scores_hist\")\n  )\n\n  list(\n    metrics_simul = metrics_simul,\n    scores_hist = scores_hist,\n    prop_scores_simul = prop_scores_simul\n  )\n}\n```\n\n\n### Grid\n\nWe consider the following grid:\n```{r define-grid-xgb}\ngrid <- expand_grid(\n  # max_depth = c(2, 4, 6),\n  max_depth = c(2,4,6),\n  nb_iter_total = 400,\n  eta = 0.3\n) |>\n  mutate(ind = row_number())\n```\n\nThe desired number of replications for each scenario needs to be set:\n```{r define-repns_vector}\nrepns_vector <- 1:100\n```\n\n\nThe different configurations are reported in @tbl-grid-values-xgb.\n\n```{r}\n#| tbl-cap: \"Grid Search Values\"\n#| label: tbl-grid-values-xgb\nDT::datatable(grid)\n```\n\n\nWe define a function, `simulate_xgb_scenario()`{.R} to train the model on a dataset for all different values of the hyperparameters of the grid. This function performs a single replication of the simulations for a single scenario.\n\n```{r define-simulate_xgb_scenario}\n#| code-fold: true\n#| code-summary: Function `simulate_xgb_scenario()`{.R}\nsimulate_xgb_scenario <- function(scenario, params_df, repn) {\n  # Generate Data\n  simu_data <- simulate_data_wrapper(\n    scenario = scenario,\n    params_df = params_df,\n    repn = repn\n  )\n\n  # Looping over the grid hyperparameters for the scenario\n  res_simul <- vector(mode = \"list\", length = nrow(grid))\n  cli::cli_progress_bar(\"Iteration grid\", total = nrow(grid), type = \"tasks\")\n  for (j in 1:nrow(grid)) {\n    curent_params <- grid |> dplyr::slice(!!j)\n    res_simul[[j]] <- simul_xgb(\n      params = curent_params,\n      ind = curent_params$ind,\n      simu_data = simu_data\n    )\n    cli::cli_progress_update()\n  }\n\n\n  # The metrics computed for all set of hyperparameters (identified with `ind`)\n  # and for each number of boosting iterations (`nb_iter`), for the current\n  # scenario (`scenario`) and current replication number (`repn`)\n  metrics_simul <- map(\n    res_simul,\n    function(simul_grid_j) map(simul_grid_j, \"tb_metrics\") |> list_rbind()\n  ) |>\n    list_rbind()\n\n  # Sanity check\n  # metrics_simul |> count(scenario, repn, ind, sample, nb_iter) |>\n  #   filter(n > 1)\n\n  # P(q_1<s(x)<q_2)\n  prop_scores_simul <- map(\n    res_simul,\n    function(simul_grid_j) map(simul_grid_j, \"tb_prop_scores\") |> list_rbind()\n  ) |>\n    list_rbind()\n\n  # Sanity check\n  # prop_scores_simul |> count(scenario, repn, ind, sample, nb_iter)\n\n  # Histogram of estimated scores\n  scores_hist <- map(\n    res_simul,\n    function(simul_grid_j) map(simul_grid_j, \"scores_hist\")\n  )\n\n  list(\n    metrics_simul = metrics_simul,\n    scores_hist = scores_hist,\n    prop_scores_simul = prop_scores_simul\n  )\n}\n```\n\n\n## Estimations\n\n\nWe loop over the 16 scenarios and run the `r max(repns_vector)` replications in parallel.\n\n```{r run-xgb-simulations, message=FALSE, warning=FALSE, eval=FALSE}\n#| code-fold: true\n#| code-summary: Estimation codes\nlibrary(pbapply)\nlibrary(parallel)\nncl <- detectCores()-1\n(cl <- makeCluster(ncl))\n\nclusterEvalQ(cl, {\n  library(tidyverse)\n  library(locfit)\n  library(philentropy)\n  library(xgboost)\n  library(ks)\n}) |>\n  invisible()\n\nclusterExport(\n  cl, c(\n    # Functions\n    \"brier_score\",\n    \"compute_metrics\",\n    \"dispersion_metrics\",\n    \"prop_btw_quantiles\",\n    \"subset_target\",\n    \"simulate_data\",\n    \"simulate_data_wrapper\",\n    \"simul_xgb\",\n    \"simulate_xgb_scenario\",\n    \"get_metrics_nb_iter\",\n    \"recalibrate\",\n    # Objects\n    \"grid\",\n    \"params_df\",\n    \"repns_vector\"\n  )\n)\n\n# make directory if not existing\nif (!dir.exists(\"../output/simul/\")) {\n  dir.create(\"../output/simul/\", recursive = TRUE)\n}\n\nfor (i_scenario in 1:16) {\n  scenario <- i_scenario\n  print(str_c(\"Scenario \", scenario, \"/\", nrow(params_df)))\n  clusterExport(cl, c(\"scenario\"))\n  resul_xgb_scenario <-\n    pblapply(\n      1:length(repns_vector), function(i) simulate_xgb_scenario(\n        scenario = scenario, params_df = params_df, repn = repns_vector[i]\n      ),\n      cl = cl\n    )\n  save(\n    resul_xgb_scenario,\n    file = str_c(\"../output/simul/resul_xgb_scenario_\", scenario, \".rda\")\n  )\n}\nstopCluster(cl)\n```\n\n\nThe results can be loaded as follows:\n\n```{r load-resul_xgb}\nscenarios <- 1:16 \nfiles <- str_c(\n  \"../output/simul/resul_xgb_scenario_\", scenarios, \".rda\"\n)\nresul_xgb <- map(files[file.exists(files)], ~{load(.x) ; resul_xgb_scenario})\n```\n\n\n\nThe `resul_rf` object is of length 16: each element contains the simulations for a scenario. For each scenario, the elements are a list of length `max(repns_vector)`, i.e., the number of replications. Each replication gives, in a list, the following elements:\n\n- `metrics_simul`: the metrics (AUC, Calibration, KL Divergence, etc.) for each model from the grid search, for all boosting iterations\n- `scores_hist`: the counts on bins defined on estimated scores (on train, validation, calibration, and test sets ; for calibration and test sets, the counts are given with or without recalibration)\n- `prop_scores_simul`: the estimations of $\\mathbb{P}(q_1 < \\hat{\\mathbf{x}}< q_2)$ for various values of `q_1` and `q_2`.\n\n## Results\n\nWe can now extract some information from the results.\n\nWe first aggregate all the computed metrics performance/calibration/divergence in a single tibble, `metrics_xgb_all`.\n```{r}\n#| code-fold: true\n#| code-summary: Codes to create the metrics table\nmetrics_xgb_all <- map(\n  resul_xgb,\n  function(resul_xgb_sc) map(resul_xgb_sc, \"metrics_simul\") |> list_rbind()\n) |>\n  list_rbind() |>\n  mutate(\n    sample = factor(\n      sample,\n      levels = c(\"train\", \"valid\", \"calib\", \"test\"),\n      labels = c(\"Train\",\"Validation\", \"Calibration\" ,\"Test\")\n    ),\n    recalib = factor(\n      recalib,\n      levels = c(\"none\", \"platt\", \"isotonic\"),\n      labels = c(\"None\", \"Platt\", \"Isotonic\")\n    )\n  )\n\n# Sanity check\n# metrics_xgb_all |> count(scenario, ind, sample, nb_iter) |>\n#   filter(n != max(repns_vector))\n```\n\nFor each replication, we made some hyperparameters vary. Let us identify some models of interest:\n\n- `smallest`: model with the lowest number of boosting iteration\n- `largest`: model with the highest number of boosting iteration\n- `largest_auc`: model with the highest AUC on validation set\n- `lowest_mse`: model with the lowest MSE on validation set\n- `lowest_ici`: model with the lowest ICI on validation set\n- `lowest_kl`: model with the lowest KL Divergence on validation set\n\n```{r xgb-identify-trees-of-interest}\n#| code-fold: true\n# Identify the smallest tree on the validation set, when the scores are not\n# recalibrated\nsmallest_xgb <-\n  metrics_xgb_all |>\n  filter(sample == \"Validation\", recalib == \"None\") |>\n  group_by(scenario, repn) |>\n  arrange(nb_iter) |>\n  slice_head(n = 1) |>\n  select(scenario, repn, ind, nb_iter, recalib) |>\n  mutate(result_type = \"smallest\") |>\n  ungroup()\n\n# Identify the largest tree\nlargest_xgb <-\n  metrics_xgb_all |>\n  filter(sample == \"Validation\", recalib == \"None\") |>\n  group_by(scenario, repn) |>\n  arrange(desc(nb_iter)) |>\n  slice_head(n = 1) |>\n  select(scenario, repn, ind, nb_iter, recalib) |>\n  mutate(result_type = \"largest\") |>\n  ungroup()\n\n# Identify tree with highest AUC on test set\nhighest_auc_xgb <-\n  metrics_xgb_all |>\n  filter(sample == \"Validation\", recalib == \"None\") |>\n  group_by(scenario, repn) |>\n  arrange(desc(AUC)) |>\n  slice_head(n = 1) |>\n  select(scenario, repn, ind, nb_iter, recalib) |>\n  mutate(result_type = \"largest_auc\") |>\n  ungroup()\n\n# Identify tree with lowest MSE\nlowest_mse_xgb <-\n  metrics_xgb_all |>\n  filter(sample == \"Validation\", recalib == \"None\") |>\n  group_by(scenario, repn) |>\n  arrange(mse) |>\n  slice_head(n = 1) |>\n  select(scenario, repn, ind, nb_iter, recalib) |>\n  mutate(result_type = \"lowest_mse\") |>\n  ungroup()\n\n# Identify tree with lowest brier\nlowest_brier_xgb <-\n  metrics_xgb_all |>\n  filter(sample == \"Validation\", recalib == \"None\") |>\n  group_by(scenario, repn) |>\n  arrange(brier) |>\n  slice_head(n = 1) |>\n  select(scenario, repn, ind, nb_iter, recalib) |>\n  mutate(result_type = \"lowest_brier\") |>\n  ungroup()\n\n# Identify tree with lowest ICI\nlowest_ici_xgb <-\n  metrics_xgb_all |>\n  filter(sample == \"Validation\", recalib == \"None\") |>\n  group_by(scenario, repn) |>\n  arrange(ici) |>\n  slice_head(n = 1) |>\n  select(scenario, repn, ind, nb_iter, recalib) |>\n  mutate(result_type = \"lowest_ici\") |>\n  ungroup()\n\n# Identify tree with lowest KL\nlowest_kl_xgb <-\n  metrics_xgb_all |>\n  filter(sample == \"Validation\", recalib == \"None\") |>\n  group_by(scenario, repn) |>\n  arrange(KL_20_true_probas) |>\n  slice_head(n = 1) |>\n  select(scenario, repn, ind, nb_iter, recalib) |>\n  mutate(result_type = \"lowest_kl\") |>\n  ungroup()\n\n# Merge these\nmodels_of_interest_xgb <-\n  smallest_xgb |>\n  bind_rows(largest_xgb) |>\n  bind_rows(highest_auc_xgb) |>\n  bind_rows(lowest_mse_xgb) |>\n  bind_rows(lowest_brier_xgb) |>\n  bind_rows(lowest_ici_xgb) |>\n  bind_rows(lowest_kl_xgb)\n\nmodels_of_interest_metrics <- NULL\nfor (recalibration_method in c(\"None\", \"Platt\", \"Isotonic\")) {\n  # Add metrics now\n  models_of_interest_metrics <-\n    models_of_interest_metrics |>\n    bind_rows(\n      models_of_interest_xgb |> select(-recalib) |>\n        left_join(\n          metrics_xgb_all |>\n            filter(\n              recalib == recalibration_method,\n              sample %in% c(\"Validation\", \"Test\")\n            ),\n          by = c(\"scenario\", \"repn\", \"ind\", \"nb_iter\"),\n          relationship = \"many-to-many\" # (calib, test)\n        )\n    )\n}\n\n\nmodels_of_interest_metrics <-\n  models_of_interest_metrics |>\n  mutate(\n    result_type = factor(\n      result_type,\n      levels = c(\n        \"smallest\", \"largest\", \"lowest_mse\", \"largest_auc\",\n        \"lowest_brier\", \"lowest_ici\", \"lowest_kl\"),\n      labels = c(\n        \"Smallest\", \"Largest\", \"MSE*\", \"AUC*\",\n        \"Brier*\", \"ICI*\", \"KL*\"\n      )\n    )\n  )\n\n# Sanity check\n# models_of_interest_metrics |> count(scenario, sample, result_type)\n```\n\n### Metrics vs Number of Iterations\n\nWe define a function, `plot_metrics()`{.R} to plot selected metrics (AUC, ICI, and KL Divergence) as a function of the number of boosting iterations, for a given value for the hyperparameter `max_depth`. Each curve corresponds to a value of the maximal depth hyperparameter.\n\nTBD\n\n### Distribution of Scores\n\nLet us extract all the histogram information computed over the simulations and put that in a single object, `scores_hist_all`.\n\n```{r define-scores_hist_all}\nscores_hist_all <-\n  map(\n    resul_xgb,\n    function(resul_xgb_sc) map(resul_xgb_sc, \"scores_hist\")\n  )\n```\n\nWe then define a function, `plot_bp_xgb()`{.R} which plots the distribution of scores on the test set for a single replication (`repn`), for a scenario, (`scenario`). We also define a helper function, `plot_bp_interest()`, which plots the histogram of the scores at a specific iteration number. We will then be able to plot the distributions at the beginning of the boosting iterations, at the end, at a point where the AUC was the highest on the validation set, and at a point where the KL divergence between the distribution of scores on the validation set and the distribution of the true probabilities was the lowest. We will plot the distributions of the scores returned by the classifier, as well as those obtained with the reclibrators.\n\n```{r define-plot_metrics}\n#| code-fold: true\n#| code-summary: Function `plot_metrics()`{.R}\nplot_bp_interest <- function(metrics_interest,\n                             scores_hist_interest,\n                             label,\n                             recalib_method) {\n  subtitle <- str_c(\n    \"Depth = \", metrics_interest$max_depth, \", \",\n    \"MSE = \", round(metrics_interest$mse, 2), \", \",\n    \"AUC = \", round(metrics_interest$AUC, 2), \", \\n\",\n    \"Brier = \", round(metrics_interest$brier, 2), \",\",\n    \"ICI = \", round(metrics_interest$ici, 2), \", \",\n    \"KL = \", round(metrics_interest$KL_20_true_probas, 2)\n  )\n\n  if (recalib_method == \"none\") {\n    plot(\n      main = str_c(label, \" (iter = \", metrics_interest$nb_iter,\")\"),\n      scores_hist_interest$test,\n      xlab = latex2exp::TeX(\"$\\\\hat{s}(x)$\"),\n      ylab = \"\"\n    )\n  } else if (recalib_method == \"platt\") {\n    plot(\n      main = str_c(label, \" (iter = \", metrics_interest$nb_iter,\")\"),\n      scores_hist_interest$test_c_platt,\n      xlab = latex2exp::TeX(\"$\\\\hat{s}(x)$\"),\n      ylab = \"\",\n      col = colour_recalib[[\"Platt\"]]\n    )\n  } else if (recalib_method == \"iso\") {\n    plot(\n      main = str_c(label, \" (iter = \", metrics_interest$nb_iter,\")\"),\n      scores_hist_interest$test_c_iso,\n      xlab = latex2exp::TeX(\"$\\\\hat{s}(x)$\"),\n      ylab = \"\",\n      col = colour_recalib[[\"Isotonic\"]]\n    )\n  }\n  mtext(side = 3, line = -0.25, adj = .5, subtitle, cex = .5)\n}\n\nplot_bp_xgb <- function(scenario,\n                        repn,\n                        paper_version = FALSE) {\n  # Focus on current scenario\n  scores_hist_scenario <- scores_hist_all[[scenario]]\n  # Focus on a particular replication\n  scores_hist_repn <- scores_hist_scenario[[repn]]\n  # # Focus on a value for max_depth\n  max_depth_val <- map_dbl(scores_hist_repn, ~.x[[1]]$max_depth)\n  # i_max_depth <- which(max_depth_val == max_depth)\n  # scores_hist <- scores_hist_repn[[i_max_depth]]\n\n  # True Probabilities\n  simu_data <- simulate_data_wrapper(\n    scenario = scenario,\n    params_df = params_df,\n    repn = repn # only one replication here\n  )\n  true_prob <- simu_data$data$probs_train\n\n  for (recalib_method in c(\"none\", \"platt\", \"iso\")) {\n\n    i_method <- match(recalib_method, c(\"none\", \"platt\", \"iso\"))\n    recalib_method_lab <- c(\"None\", \"Platt\", \"Isotonic\")[i_method]\n\n    # The metrics for the corresponding simulations, on the validation set\n    metrics_xgb_current_valid <-\n      metrics_xgb_all |>\n      filter(\n        scenario == !!scenario,\n        repn == !!repn,\n        sample == \"Validation\",\n        recalib == \"None\"\n      )\n    # and on the test set\n    metrics_xgb_current_test <-\n      metrics_xgb_all |>\n      filter(\n        scenario == !!scenario,\n        repn == !!repn,\n        sample == \"Test\",\n        recalib == recalib_method_lab\n      )\n\n    if (paper_version == FALSE) {\n      hist(\n        true_prob,\n        breaks = seq(0, 1, by = .05),\n        xlab = \"p\", ylab = \"\",\n        main = \"True Probabilities\",\n        xlim = c(0, 1)\n      )\n      mtext(\n        side = 2, recalib_method_lab, line = 2.5, cex = 1,\n        font.lab = 2\n      )\n      # Iterations of interest----\n      ## Start of iterations\n      scores_hist_start <- scores_hist_repn[[1]][[1]]\n      metrics_start <- metrics_xgb_current_test |>\n        filter(\n          nb_iter == scores_hist_start$nb_iter,\n          max_depth == scores_hist_start$max_depth\n        )\n\n      plot_bp_interest(\n        metrics_interest = metrics_start,\n        scores_hist_interest = scores_hist_start,\n        label = \"Start\",\n        recalib_method = recalib_method\n      )\n\n      ## End of iterations\n      scores_hist_end <- scores_hist_repn[[1]][[length(scores_hist_repn[[1]])]]\n      metrics_end <- metrics_xgb_current_test |>\n        filter(\n          nb_iter == scores_hist_end$nb_iter,\n          max_depth == scores_hist_start$max_depth\n        )\n      plot_bp_interest(\n        metrics_interest = metrics_end,\n        scores_hist_interest = scores_hist_end,\n        label = \"End\",\n        recalib_method = recalib_method\n      )\n\n      ## Iteration with min MSE on validation set\n      metrics_valid_mse_star <- metrics_xgb_current_valid |> arrange(mse) |>\n        dplyr::slice(1)\n      nb_iter_mse <- metrics_valid_mse_star$nb_iter\n      max_depth_mse_star <- metrics_valid_mse_star$max_depth\n      i_max_depth_mse_star <- which(max_depth_val == max_depth_mse_star)\n      # Metrics at the same iteration on the test set\n      metrics_min_mse <-\n        metrics_xgb_current_test |>\n        filter(\n          nb_iter == !!nb_iter_mse,\n          max_depth == max_depth_mse_star\n        )\n      # Note: indexing at 0 here...\n      ind_mse <- which(map_dbl(scores_hist_repn[[i_max_depth_mse_star]], \"nb_iter\") == nb_iter_mse)\n      scores_hist_min_mse <- scores_hist_repn[[i_max_depth_mse_star]][[ind_mse]]\n      plot_bp_interest(\n        metrics_interest = metrics_min_mse,\n        scores_hist_interest = scores_hist_min_mse,\n        label = \"MSE*\",\n        recalib_method = recalib_method\n      )\n    }\n    ## Iteration with max AUC on validation set\n    metrics_valid_auc_star <-\n      metrics_xgb_current_valid |> arrange(desc(AUC)) |> dplyr::slice(1)\n    nb_iter_auc <- metrics_valid_auc_star$nb_iter\n    max_depth_auc_star <- metrics_valid_auc_star$max_depth\n    i_max_depth_auc_star <- which(max_depth_val == max_depth_auc_star)\n\n    metrics_max_auc <-\n      metrics_xgb_current_test |>\n      filter(nb_iter == !!nb_iter_auc, max_depth == max_depth_auc_star)\n    # Note: indexing at 0 here...\n    ind_auc <- which(map_dbl(scores_hist_repn[[i_max_depth_auc_star]], \"nb_iter\") == nb_iter_auc)\n    scores_hist_max_auc <- scores_hist_repn[[i_max_depth_auc_star]][[ind_auc]]\n    plot_bp_interest(\n      metrics_interest = metrics_max_auc,\n      scores_hist_interest = scores_hist_max_auc,\n      label = \"AUC*\",\n      recalib_method = recalib_method\n    )\n    if (paper_version == TRUE) {\n      mtext(\n        side = 2, recalib_method_lab, line = 2.5, cex = 1,\n        font.lab = 2\n      )\n    }\n\n    ## Min Brier on validation set\n    metrics_valid_brier_star <-\n      metrics_xgb_current_valid |> arrange(brier) |> dplyr::slice(1)\n    nb_iter_brier <- metrics_valid_brier_star$nb_iter\n    max_depth_brier_star <- metrics_valid_brier_star$max_depth\n    i_max_depth_brier_star <- which(max_depth_val == max_depth_brier_star)\n\n    metrics_min_brier <-\n      metrics_xgb_current_test |>\n      filter(nb_iter == !!nb_iter_brier, max_depth == max_depth_brier_star)\n    ind_brier <- which(map_dbl(scores_hist_repn[[i_max_depth_brier_star]], \"nb_iter\") == nb_iter_brier)\n    scores_hist_min_brier <- scores_hist_repn[[i_max_depth_brier_star]][[ind_brier]]\n    plot_bp_interest(\n      metrics_interest = metrics_min_brier,\n      scores_hist_interest = scores_hist_min_brier,\n      label = \"Brier*\",\n      recalib_method = recalib_method\n    )\n\n    ## Min ICI on validation set\n    metrics_valid_ici_star <-\n      metrics_xgb_current_valid |> arrange(ici) |> dplyr::slice(1)\n    nb_iter_ici <-   metrics_valid_ici_star$nb_iter\n    max_depth_ici_star <- metrics_valid_ici_star$max_depth\n    i_max_depth_ici_star <- which(max_depth_val == max_depth_ici_star)\n\n    metrics_min_ici <-\n      metrics_xgb_current_test |>\n      filter(nb_iter == !!nb_iter_ici, max_depth == max_depth_ici_star)\n    ind_ici <- which(map_dbl(scores_hist_repn[[i_max_depth_ici_star]], \"nb_iter\") == nb_iter_ici)\n    scores_hist_min_ici <- scores_hist_repn[[i_max_depth_ici_star]][[ind_ici]]\n    plot_bp_interest(\n      metrics_interest = metrics_min_ici,\n      scores_hist_interest = scores_hist_min_ici,\n      label = \"ICI*\",\n      recalib_method = recalib_method\n    )\n\n    ## Min KL on validation set\n    metrics_valid_kl_star <-\n      metrics_xgb_current_valid |> arrange(KL_20_true_probas) |> dplyr::slice(1)\n    nb_iter_kl <-   metrics_valid_kl_star$nb_iter\n    max_depth_kl_star <- metrics_valid_kl_star$max_depth\n    i_max_depth_kl_star <- which(max_depth_val == max_depth_kl_star)\n\n    metrics_min_kl <-\n      metrics_xgb_current_test |>\n      filter(nb_iter == !!nb_iter_kl, max_depth == max_depth_kl_star)\n    ind_kl <- which(map_dbl(scores_hist_repn[[i_max_depth_kl_star]], \"nb_iter\") == nb_iter_kl)\n    scores_hist_min_kl <- scores_hist_repn[[i_max_depth_kl_star]][[ind_kl]]\n    plot_bp_interest(\n      metrics_interest = metrics_min_kl,\n      scores_hist_interest = scores_hist_min_kl,\n      label = \"KL*\",\n      recalib_method = recalib_method\n    )\n  }\n}\n```\n\n:::{.panel-tabset}\n#### DGP 1\n::::{.panel-tabset}\n##### 0 noise variable\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 1, 0 noise variable)\n#| label: fig-xgb-bp-1-0\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 1, repn = 1)\n```\n##### 10 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 1, 10 noise variables)\n#| label: fig-xgb-bp-1-10\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 2, repn = 1)\n```\n##### 50 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 1, 50 noise variables)\n#| label: fig-xgb-bp-1-50\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 3, repn = 1)\n```\n##### 100 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 1, 100 noise variables)\n#| label: fig-xgb-bp-1-100\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 4, repn = 1)\n```\n::::\n#### DGP 2\n::::{.panel-tabset}\n##### 0 noise variable\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 2, 0 noise variable)\n#| label: fig-xgb-bp-2-0\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 5, repn = 1)\n```\n##### 10 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 2, 10 noise variables)\n#| label: fig-xgb-bp-2-10\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 6, repn = 1)\n```\n##### 50 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 2, 50 noise variables)\n#| label: fig-xgb-bp-2-50\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 7, repn = 1)\n```\n##### 100 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 2, 100 noise variables)\n#| label: fig-xgb-bp-2-100\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 8, repn = 1)\n```\n::::\n#### DGP 3\n::::{.panel-tabset}\n##### 0 noise variable\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 3, 0 noise variable)\n#| label: fig-xgb-bp-3-0\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 9, repn = 1)\n```\n##### 10 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 3, 10 noise variables)\n#| label: fig-xgb-bp-3-10\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 10, repn = 1)\n```\n##### 50 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 3, 50 noise variables)\n#| label: fig-xgb-bp-3-50\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 11, repn = 1)\n```\n##### 100 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 3, 100 noise variables)\n#| label: fig-xgb-bp-3-100\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 12, repn = 1)\n```\n::::\n#### DGP 4\n::::{.panel-tabset}\n##### 0 noise variable\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 4, 0 noise variable)\n#| label: fig-xgb-bp-4-0\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 13, repn = 1)\n```\n##### 10 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 4, 10 noise variables)\n#| label: fig-xgb-bp-4-10\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 14, repn = 1)\n```\n##### 50 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 4, 50 noise variables)\n#| label: fig-xgb-bp-4-50\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 15, repn = 1)\n```\n##### 100 noise variables\n```{r, warning=FALSE, message=FALSE}\n#| fig-cap: Distribution of scores on the test set (DGP 4, 100 noise variables)\n#| label: fig-xgb-bp-4-100\n#| code-fold: true\n#| fig-height: 6\n#| fig-width: 12\npar(mfrow = c(3,8), mar = c(4.1, 4, 3.5, 1.5))\nplot_bp_xgb(scenario = 16, repn = 1)\n```\n::::\n:::\n\n\n\n```{r, eval=FALSE}\n#| code-fold: true\n#| code-summary: Code to create PDF figures\nfor (scenario in 1:16) {\n  pdf(\n    file = str_c(\"../figs/bp_synthetic_xbg_\", scenario, \".pdf\"),\n    height = 4.5, width = 10\n  )\n  par(mfrow = c(3,4), mar = c(4.1, 4, 3.5, 1.5))\n  plot_bp_xgb(scenario = scenario, repn = 1, paper_version = TRUE)\n  dev.off()\n}\n```\n\n\n\n### KL Divergence and Calibration along Boosting Iterations\n\nWe can examine the evolution of the relationship between the divergence of score distributions from true probabilities and model calibration across increasing boosting iterations.\n\n```{r define-df_plot}\n#| code-fold: true\n#| code-summary: Codes to create the figure\n#| fig-cap: KL Divergence and Calibration across increasing boosting iterations\n#| label: fig-kl-calib-xgb-iterations\n#| fig-width: 10\n#| fig-height: 8\ndf_plot <-\n  metrics_xgb_all |>\n  mutate(\n    dgp = case_when(\n      scenario %in% 1:4 ~ 1,\n      scenario %in% 5:8 ~ 2,\n      scenario %in% 9:12 ~ 3,\n      scenario %in% 13:16 ~ 4\n    ),\n    dgp = factor(dgp, levels = 1:4, labels = str_c(\"DGP \", 1:4)),\n    no_noise = c(0, 10, 50, 100)[(scenario-1)%%4 + 1],\n    no_noise = factor(\n      no_noise, levels = c(no_noise),\n      labels = str_c(no_noise, \" noise variables\")\n    )\n  ) |>\n  select(\n    dgp, no_noise, scenario, recalib, ind, sample, nb_iter, max_depth,\n    brier, ici, KL_20_true_probas\n  ) |>\n  group_by(dgp, no_noise, scenario, recalib, ind, sample, nb_iter, max_depth) |>\n  summarise(\n    brier = mean(brier),\n    ici = mean(ici),\n    KL_20_true_probas = mean(KL_20_true_probas),\n    .groups = \"drop\"\n  ) |>\n  mutate(\n    max_depth = factor(\n      max_depth,\n      levels = c(2, 4, 6)\n    )\n  )\n\nformatter1000 <- function(x) x*1000\n```\n\n::: {.panel-tabset}\n\n#### Brier\n\n```{r}\n#| code-fold: true\n#| code-summary: Codes to create the figure\n#| fig-cap: KL Divergence and Calibration (Brier) across increasing boosting iterations (log scales)\n#| label: fig-kl-calib-brier-xgb-iterations\n#| fig-width: 10\n#| fig-height: 8\np_brier <- ggplot(\n  data = df_plot |> arrange(nb_iter) |> filter(max_depth == 2),\n  mapping = aes(x = brier, y = KL_20_true_probas)\n) +\n  geom_path(\n    mapping = aes(colour = sample, linetype = recalib),\n    arrow = arrow(type = \"closed\", ends = \"last\",\n                  length = unit(0.08, \"inches\"))\n  ) +\n  # facet_wrap(~scenario) +\n  ggh4x::facet_grid2(dgp~no_noise, scales = \"free_y\", independent = \"y\") +\n  labs(\n    x = latex2exp::TeX(\"Calibration (Brier), $\\\\times 10^{3}$, log scale\"),\n    y = \"KL Divergence\"\n  ) +\n  scale_x_log10(labels = formatter1000) + scale_y_log10() +\n  scale_colour_manual(\"Sample\", values = colour_samples) +\n  scale_linetype_discrete(\"Recalibration\") +\n  theme_paper() +\n  theme(legend.key.width = unit(1.5, \"cm\"))\n\n\nggsave(\n  p_brier, file = \"../figs/xgb-kl-calib-brier-leaves-all.pdf\",\n       width = 10, height = 8\n)\n\np_brier\n```\n\n#### ICI\n\n\n```{r}\n#| code-fold: true\n#| code-summary: Codes to create the figure\n#| fig-cap: KL Divergence and Calibration (ICI) across increasing boosting iterations (log scales)\n#| label: fig-kl-calib-ici-xgb-iterations\n#| fig-width: 10\n#| fig-height: 8\np_ici <- ggplot(\n  data = df_plot |> arrange(nb_iter) |> filter(max_depth == 2),\n  mapping = aes(x = ici, y = KL_20_true_probas)\n) +\n  geom_path(\n    mapping = aes(colour = sample, linetype = recalib),\n    arrow = arrow(type = \"closed\", ends = \"last\",\n                  length = unit(0.08, \"inches\"))\n  ) +\n  # facet_wrap(~scenario) +\n  ggh4x::facet_grid2(dgp~no_noise, scales = \"free_y\", independent = \"y\") +\n  labs(\n    x = latex2exp::TeX(\"Calibration (ICI), $\\\\times 10^{3}$, log scale\"),\n    y = \"KL Divergence\"\n  ) +\n  scale_x_log10(labels = formatter1000) + scale_y_log10() +\n  scale_colour_manual(\"Sample\", values = colour_samples) +\n  scale_linetype_discrete(\"Recalibration\") +\n  theme_paper() +\n  theme(legend.key.width = unit(1.5, \"cm\"))\n\n\nggsave(\n  p_ici, file = \"../figs/xgb-kl-calib-ici-leaves-all.pdf\",\n  width = 10, height = 8\n)\np_ici\n```\n\n\n:::\n\n\n\n### Tables\n\n```{r}\nmodels_interest_xgb <- models_of_interest_metrics |> \n  group_by(scenario, recalib, sample, result_type) |> \n  summarise(\n    AUC_lower = quantile(AUC, probs = 2.5/100),\n    AUC_upper = quantile(AUC, probs = 97.5/100),\n    AUC_sd = sd(AUC),\n    AUC = mean(AUC),\n    brier_lower = quantile(brier, probs = 2.5/100),\n    brier_upper = quantile(brier, probs = 97.5/100),\n    brier_sd = sd(brier),\n    brier = mean(brier),\n    ici_lower = quantile(ici, probs = 2.5/100),\n    ici_upper = quantile(ici, probs = 97.5/100),\n    ici_sd = sd(ici),\n    ici = mean(ici),\n    KL_20_true_probas_lower = quantile(KL_20_true_probas, probs = 2.5/100),\n    KL_20_true_probas_upper = quantile(KL_20_true_probas, probs = 97.5/100),\n    KL_20_true_probas_sd = sd(KL_20_true_probas),\n    KL_20_true_probas = mean(KL_20_true_probas),\n    quant_ratio_sd = sd(inter_quantile_10_90),\n    quant_ratio = mean(inter_quantile_10_90),\n    .groups = \"drop\"\n  ) |> \n  mutate(\n    model = \"xgb\",\n    sample = str_to_lower(as.character(sample))\n  )\n\n# Sanity check\n# metrics_xgb_all |> count(scenario, recalib, ind, sample, nb_iter) |>\n#   filter(n != max(repns_vector))\n\ntable_models_interest_mean <- \n  models_interest_xgb |> \n  filter(sample == \"test\") |> \n  select(\n    scenario, recalib, sample, result_type, \n    AUC, brier, ici, kl = KL_20_true_probas, quant_ratio\n  ) |> \n  filter(\n    result_type %in% c(\"AUC*\", \"Brier*\", \"ICI*\", \"KL*\")\n  ) |> \n  mutate(value_type = \"mean\")\n\n\ntable_models_interest_sd <- \n  models_interest_xgb |> \n  filter(sample == \"test\") |> \n  select(\n    scenario, sample, model, result_type, \n    AUC = AUC_sd, brier = brier_sd, ici = ici_sd, \n    kl = KL_20_true_probas_sd, quant_ratio = quant_ratio_sd\n  ) |> \n  filter(\n    result_type %in% c(\"AUC*\", \"Brier*\", \"ICI*\", \"KL*\")\n  ) |> \n  mutate(value_type = \"sd\")\n\n\ntable_models_interest_mean |> \n  # bind_rows(table_models_interest_sd) |> \n  filter(scenario==5) |> \n  select(-sample, -brier, -quant_ratio) |> \n  pivot_wider(names_from = recalib, values_from = c(AUC, ici, kl)) |> \n  select(-value_type) |> \n  filter(result_type != \"Brier*\") |> \n  mutate(\n    delta_platt = kl_None - kl_Platt,\n    delta_iso = kl_None - kl_Isotonic,\n    )\n```\n\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","filters":["pseudocode"],"from":"markdown+emoji","highlight-style":"github","html-math-method":"mathjax","include-in-header":[{"file":"mathjax-color.html"}],"output-file":"simul-xgb.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.553","bibliography":["biblio.bib"],"fig-cap-location":"top","editor":"source","theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}